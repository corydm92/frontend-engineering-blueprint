6. Mixing Code-Split and Non<ETH>Code-Split Routes

By default, Next.js code-splits every route segment inside the /app directory.
Each folder (like /dashboard, /dashboard/invoices) becomes its own boundary „ meaning separate JS chunks and network requests when navigating between them.

However, in some cases (like dashboards or internal tools), itÍs more efficient to bundle related routes together into one SSR payload and load them eagerly while still maintaining navigation via the router.

------------------------------------------------------------
Goal

- Keep all routes navigable using Next.js routing (e.g., /dashboard/invoices, /dashboard/customers).
- Prevent additional network fetches or chunk loads when switching between sub-routes.
- Render the entire dashboard area as a single SSR payload and bundle.

------------------------------------------------------------
Before (Default Route-Splitting)

/app

???
dashboard/
??? layout.tsx
??? page.tsx ? /dashboard
??? customers/page.tsx ? /dashboard/customers

???
invoices/page.tsx ? /dashboard/invoices

Each folder under /dashboard is its own segment:
- Navigating to /dashboard/customers triggers a new fetch for that segmentÍs RSC payload.
- Each route becomes a separate JS chunk.
- This isolates failures but causes extra round trips.

------------------------------------------------------------
After (Eager-Bundled Routes)

/app

???
dashboard/
??? layout.tsx
??? page.tsx
??? customers/page.tsx

???
invoices/page.tsx

Inside /dashboard/page.tsx, statically import the sub-pages and render them conditionally:

Example:
'use client';
import { usePathname } from 'next/navigation';
import DashboardHome from './home';
import CustomersPage from './customers/page';
import InvoicesPage from './invoices/page';

export default function DashboardPage() {
const pathname = usePathname();

return (
<div>
<Header />
<Nav />
{pathname === '/dashboard' && <DashboardHome />}
{pathname === '/dashboard/customers' && <CustomersPage />}
{pathname === '/dashboard/invoices' && <InvoicesPage />}
</div>
);
}

How it works:
- All child pages (home, customers, invoices) are statically imported into one bundle.
- The route still changes normally with router.push() or <Link>.
- No new RSC fetches occur „ React simply swaps rendered components.
- The entire dashboard module is server-rendered as one payload.

------------------------------------------------------------
Forcing Full SSR (Optional)

If you want the dashboard to be rendered entirely on the server with no streaming or client-side fragmentation:
export const dynamic = 'force-dynamic';

This ensures the route is rendered fully in one server pass before being sent to the browser.

------------------------------------------------------------
Result

?
All sub-pages load with the initial bundle „ no additional fetches.
?
Route navigation is instant (no network round trip).
?
SSR still works normally.
?
Router state and URLs remain intact.

??
Larger initial JS payload.
??
Loss of per-segment isolation (errors or revalidation affect the whole route).

------------------------------------------------------------
Summary

To disable code splitting for specific routes while keeping navigation:
- Statically import sub-pages into a parent page (same layout boundary).
- Conditionally render them based on pathname.
- Optionally mark the route as dynamic to force full SSR rendering.

This pattern trades modular splitting for a single, eager SSR bundle „ ideal for dashboards or internal admin sections where all subviews are needed frequently.
