5. React Suspense Integration

Next.js integrates React’s Suspense boundaries for async rendering on both the server and client, enabling partial rendering and streaming.

--------------------------------------------------------------------------------

On the server:
- Suspense defers parts of the component tree while awaiting async resources (data, code, or components).
- Next.js streams HTML in chunks as each Suspense boundary resolves, so users start seeing content earlier.
- While a boundary is pending, Next.js sends the fallback HTML (like a loading spinner) and continues rendering the rest of the page server-side.
- Once the awaited data or component is ready, the resolved HTML stream replaces the fallback seamlessly.

On the client:
- Suspense coordinates hydration — pausing UI rendering until a lazy-loaded component or data segment finishes loading.
- After hydration completes, React swaps the fallback with the loaded component, maintaining continuity.

--------------------------------------------------------------------------------

Two Ways to Implement Streaming in Next.js

1. At the Page Level (with loading.tsx)
- Next.js automatically wraps your page in a Suspense boundary when a loading.tsx file is present.
- This creates a default streaming boundary for that route segment.

Example:
------------------------------------------------------------
// app/dashboard/loading.tsx
export default function Loading() {
return <p>Loading dashboard...</p>
}

// app/dashboard/page.tsx
export default async function Page() {
const data = await getData();
return <div>{data}</div>
}
------------------------------------------------------------

Result:
The fallback (loading.tsx) renders instantly while the page’s async data or components stream in when ready.

2. At the Component Level (manual <Suspense>)
- For more granular control, you can wrap individual components in <Suspense> to define their own streaming boundaries.

Example:
------------------------------------------------------------
import { Suspense } from 'react';
import Cards from './Cards';
import RevenueChart from './RevenueChart';
import LatestInvoices from './LatestInvoices';
import Loading from './loading';

export default function DashboardPage() {
return (
<>
<Suspense fallback={<Loading />}>
<Cards />
</Suspense>

<Suspense fallback={<Loading />}>
<RevenueChart />
</Suspense>

<Suspense fallback={<Loading />}>
<LatestInvoices />
</Suspense>
</>
);
}
------------------------------------------------------------

Result:
Each section streams independently, allowing faster content display and improved perceived performance.

--------------------------------------------------------------------------------

In effect:
Suspense acts as a coordination layer between React Server Components (RSC) streaming and client hydration.
It enables progressive rendering — users interact with visible parts of the page while slower sections load in the background.
Next.js leverages this model for instant time-to-first-byte (TTFB) and non-blocking UX, essential to its app router and server rendering architecture.