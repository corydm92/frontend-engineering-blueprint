1. Static vs Dynamic Routes

Next.js distinguishes between static and dynamic routes at build time to decide how each route is rendered, prefetched, and cached.
Understanding this distinction helps you predict when pages are fully prefetched and when the browser must wait for the server to stream new data.

------------------------------------------------------------
Static Routes

A static route has no dynamic parameters in its path and does not depend on request-time data.
Static routes are prerendered at build time, cached by the server, and can be prefetched completely.

Examples:
/about
/contact
/pricing

Behavior:
- Fully prerendered to HTML and RSC payloads at build time.
- Automatically prefetched by <Link> when visible.
- Navigation requires no server fetch „ everything is already cached locally.
- Suitable for stable or unchanging content.

Rendering Mode:
- Static Rendering (Prerendering): HTML and RSC payload are built ahead of time.
- Can be revalidated with Incremental Static Regeneration (ISR) for controlled cache updates.

------------------------------------------------------------
Dynamic Routes

A dynamic route includes parameters or depends on runtime data, so it must be rendered at request time.

Examples:
/blog/[slug]
/dashboard/[id]/settings
/products/[category]/[id]

Behavior:
- Not prefetched fully by default to avoid unnecessary server work.
- If loading.tsx exists, partial prefetching occurs:
- Shared layouts and loading UI are fetched first.
- The pageÍs actual RSC payload streams after user navigation.
- Each visit may involve new server rendering (depending on fetch caching and revalidation settings).
- Navigation remains instant visually because the loading fallback renders immediately.

Rendering Mode:
- Dynamic Rendering: The route is generated at request time using live data.
- Controlled via fetch options (cache: 'no-store' or revalidate) and generateStaticParams().

------------------------------------------------------------
Detecting Route Type

Next.js determines whether a route is static or dynamic by analyzing:
1. URL parameters ([slug], [id], etc.)
2. Presence of generateStaticParams() ? enables prerendering for dynamic segments.
3. Usage of fetch() or dynamic data functions with runtime options (cache: 'no-store' forces dynamic).

Good to know:
- Dynamic routes without generateStaticParams() fall back to runtime rendering.
- You can verify route behavior in development using the Next.js dev overlay (Dev Indicators).

------------------------------------------------------------
Examples

Static:
app/about/page.tsx
export default function About() {
return <h1>About</h1>
}

Dynamic:
app/blog/[slug]/page.tsx
export default async function BlogPost({ params }: { params: { slug: string } }) {
const post = await getPost(params.slug);
return <PostView post={post} />
}

Static dynamic hybrid:
app/blog/[slug]/page.tsx
export async function generateStaticParams() {
const posts = await getAllPosts();
return posts.map((post) => ({ slug: post.slug }));
}

export default async function BlogPost({ params }: { params: { slug: string } }) {
const post = await getPost(params.slug);
return <PostView post={post} />
}

This example prerenders all known posts but still supports new ones dynamically after build.

------------------------------------------------------------
Summary

Static routes ? built once, fully prefetched, instant navigation.
Dynamic routes ? rendered on demand, partially prefetched when loading.tsx exists, streamed via Suspense.
Next.js automatically chooses between static and dynamic behavior based on route structure, caching configuration, and data dependencies.
