2. Route Classification and Data Fetching Behavior

Before Next.js decides how to render or cache a route, it performs a static analysis during build to classify each route as Static, ISR, or Dynamic.
This classification step determines which files get prerendered and which routes will stream live data at runtime.

------------------------------------------------------------
1. Classification Inputs

Next.js inspects the following to determine render behavior:

1. URL Pattern
Static routes (no parameters): /about, /contact „ can always be prerendered.
Dynamic routes ([id], [slug]) „ evaluated based on whether params can be generated.

2. generateStaticParams()
If defined, Next.js calls it at build time to enumerate valid parameter values.
Each parameter value becomes its own prerendered page.
Without it, the route cannot be built statically and defaults to runtime rendering.

3. fetch() Calls
fetch('url') defaults to `cache: 'force-cache'` „ Static
fetch('url', { next: { revalidate: N } }) „ ISR (revalidates on interval)
fetch('url', { cache: 'no-store' }) „ Dynamic (fetches per request)
fetch('url', { next: { revalidate: 0 } }) „ Dynamic equivalent

4. Global Route Flags
export const revalidate = 60 „ enables ISR globally for that route
export const dynamic = 'force-dynamic' „ forces runtime rendering
export const dynamicParams = false „ disables fallback behavior for missing params

------------------------------------------------------------
2. Build-Time Decision Flow

Simplified internal logic:

1. Next.js scans all route files in /app.
2. For each route:
- Check for dynamic segments
- Check for generateStaticParams()
- Analyze fetch() usage and revalidate settings
3. Based on these checks:
- If all data is cacheable ? Static route
- If revalidate is defined ? ISR route
- If any no-store or unbounded async behavior ? Dynamic route
4. Tag each route internally as:
static, revalidated, or dynamic
5. Emit the correct build artifact type:
- .html + .rsc for static or ISR routes
- runtime render function for dynamic routes

------------------------------------------------------------
3. Example Summary

Static Route
app/about/page.tsx
export default async function Page() {
const data = await fetch('https://api.example.com/info');
return <About data={data} />
}
fetch() defaults to 'force-cache'
Built once during build
Produces /about.html + /about.rsc

ISR Route
app/blog/page.tsx
export default async function Page() {
const res = await fetch('https://api.example.com/posts', { next: { revalidate: 120 } });
const posts = await res.json();
return <Blog posts={posts} />
}
Prerendered initially
Revalidates every 120 seconds
Produces prerendered output that updates periodically

Dynamic Route
app/dashboard/page.tsx
export const dynamic = 'force-dynamic';
export default async function Page() {
const data = await fetch('https://api.example.com/metrics', { cache: 'no-store' });
return <Dashboard data={data} />
}
Executed at request time
Streams serialized React payload
Produces runtime function, not .html

------------------------------------------------------------
4. Outcome of Classification

Detected Condition ? Rendering Mode ? Build Output ? Data Fetch Timing

No dynamic data ? Static ? .html + .rsc ? Build time
Uses revalidate ? ISR ? .html + .rsc ? Build + periodic regeneration
cache: 'no-store' ? Dynamic ? runtime module ? Per request
generateStaticParams() present ? Static (per param) ? .html + .rsc per param ? Build time
Missing generateStaticParams() ? Dynamic fallback ? runtime module ? Per request

------------------------------------------------------------
5. Why It Matters

This classification determines:
- Whether a route is prebuilt or rendered dynamically
- What files are emitted to .next/server/app
- Whether the user sees cached HTML or a streamed React payload
- How navigation prefetching behaves (static ? full prefetch, dynamic ? partial or none)

Next.js doesnÍt wait until runtime to decide „ the classification happens at build time, shaping every subsequent optimization step.
