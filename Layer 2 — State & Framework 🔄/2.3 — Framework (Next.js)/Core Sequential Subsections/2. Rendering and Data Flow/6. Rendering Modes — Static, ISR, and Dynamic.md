6. Rendering Modes — Static, ISR, and Dynamic

Next.js supports three primary rendering modes that determine when and how a route’s HTML and RSC payload are generated and cached:
Static Rendering, Incremental Static Regeneration (ISR), and Dynamic Rendering.

Each mode affects when data is fetched, how long it’s cached, and whether the browser receives prebuilt artifacts or streamed React payloads.

------------------------------------------------------------
1. Static Rendering (Build Time)

When no dynamic data or caching overrides are detected, Next.js treats the route as static.
All `fetch()` calls default to `cache: 'force-cache'`, meaning data is fetched once at build time and embedded into the prerendered HTML and RSC files.

Example:
export default async function Page() {
const res = await fetch('https://api.example.com/posts');
const posts = await res.json();
return <PostsList posts={posts} />
}

Behavior:
- Executes once at build time.
- Produces .html (static markup) + .rsc (serialized component structure).
- Served instantly from CDN or edge cache.
- No new server rendering occurs on user visits.

Browser delivery:
- Receives prerendered HTML shell + RSC payload.
- Hydration attaches interactivity as JS bundles load.

------------------------------------------------------------
2. Incremental Static Regeneration (ISR)

ISR allows static routes to update automatically after deployment, without a full rebuild.
The route revalidates at intervals defined in seconds via the `next.revalidate` option.

Example:
export default async function Page() {
const res = await fetch('https://api.example.com/posts', {
next: { revalidate: 60 },
});
const posts = await res.json();
return <PostsList posts={posts} />
}

Behavior:
- The first build creates .html and .rsc files as usual.
- On request:
- If cache is fresh → serve from CDN instantly.
- If stale → serve old response, regenerate new HTML + RSC in background.
- The next visitor receives updated prerendered output.
- The cache revalidation timer resets after regeneration.

Browser delivery:
- Same static assets, but periodically refreshed behind the scenes.
- No blocking wait — users always get a response.

Tradeoff:
✅ Near-instant loads.
✅ Automatic freshness.
❌ Data may be briefly stale between revalidations.

------------------------------------------------------------
3. Dynamic Rendering (Per Request)

Dynamic rendering disables caching and forces the server to render at request time.
Each request generates a new RSC payload and sends it to the client as a React stream.

Example:
export const dynamic = 'force-dynamic';
export default async function Page() {
const res = await fetch('https://api.example.com/posts', { cache: 'no-store' });
const posts = await res.json();
return <PostsList posts={posts} />
}

Behavior:
- Fetch runs for every request.
- No .html file exists at build time.
- Output is generated per request on the server.
- The response is streamed to the browser as:
- Initial HTML shell for the layout.
- React Flight payload containing component structure and props.
- References to client JS bundles for hydration.

This ensures always-fresh data but requires live server rendering.

------------------------------------------------------------
4. Comparison Table

| Mode | When fetch() runs | .html file? | Cacheable? | Updates automatically? | Data Freshness | Delivery Type |
|------|--------------------|--------------|-------------|------------------------|----------------|----------------|
| Static | Build time | ✅ Yes | ✅ CDN/disk | ❌ Needs rebuild | Frozen | HTML + RSC |
| ISR | Build + revalidation | ✅ Yes | ✅ CDN w/ timer | ✅ Background refresh | Eventually fresh | HTML + RSC |
| Dynamic | Each request | ❌ No | ❌ Per request | ✅ Always live | Always fresh | Streamed RSC payload |

------------------------------------------------------------
5. Relationship with Route Types

Static and dynamic rendering are independent of URL patterns.
Both `/about` and `/blog/[slug]` can use any mode:

- `/blog/[slug]` can be static if it uses `generateStaticParams()`.
- `/about` can be dynamic if it fetches data with `cache: 'no-store'`.

"Dynamic route" (variable URL) ≠ "Dynamic rendering" (live data).

------------------------------------------------------------
6. What the Browser Actually Receives

For all modes:
- The browser never receives raw server-rendered HTML for the full tree.
- It receives a mix of:
- Static HTML shell (layout and already-resolved server markup).
- RSC payload (serialized React Flight instructions).
- Client JS bundles (hydration entry points).

Static and ISR routes send these assets as prebuilt files.
Dynamic routes generate them on the fly and stream the serialized RSC payload progressively.

------------------------------------------------------------
7. Summary

- Static Rendering: Prerendered HTML and RSC payload built once. Fastest delivery.
- ISR: Static output with timed regeneration. Balances speed and freshness.
- Dynamic Rendering: No cache; server generates RSC payload per request for live data.
- The type of route (static or dynamic URL) doesn’t dictate rendering mode — caching and fetch policies do.
- React never streams full HTML; it streams structured RSC data, which the browser rehydrates into a live UI.

In essence:
Static and ISR routes serve prebuilt assets; dynamic routes generate and stream serialized component data.
The browser always reconstructs the final UI through React hydration — not by parsing new HTML.