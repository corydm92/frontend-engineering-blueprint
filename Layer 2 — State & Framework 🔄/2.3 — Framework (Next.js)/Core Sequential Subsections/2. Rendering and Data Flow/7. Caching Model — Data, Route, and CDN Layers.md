7. Caching Model — Data, Route, and CDN Layers

Next.js maintains multiple layers of caching that work together to optimize both data retrieval and page delivery.
Understanding how these caches interact helps explain when data updates appear, how revalidation works, and why some routes serve instantly while others re-render.

------------------------------------------------------------
1. Overview

There are three primary caching layers:

1. Data Cache — Stores results of server-side fetch() calls.
2. Route Cache — Stores rendered route outputs (.html + .rsc).
3. CDN / Edge Cache — Stores delivered assets for distribution to users.

Each layer can be independently invalidated or bypassed depending on fetch options, route configuration, and deployment platform.

------------------------------------------------------------
2. Data Cache (Fetch-Level)

Every fetch() in a Server Component participates in React’s data cache.

- Default: `cache: 'force-cache'` → result is stored at build or runtime.
- ISR: `next: { revalidate: N }` → result expires after N seconds, triggers re-fetch in background.
- Dynamic: `cache: 'no-store'` → result is never cached, always fetched fresh.

Scope:
- Only applies to data requests made by fetch().
- Cached in memory or filesystem depending on deployment (Edge / Node).
- Shared between builds and revalidations if cache is persistent.

Example:
await fetch('https://api.example.com/posts', { next: { revalidate: 300 } });

Behavior:
- Serves cached data if younger than 5 minutes.
- When expired, fetches new data and updates the cache asynchronously.

------------------------------------------------------------
3. Route Cache (Page-Level)

Once a route is rendered, Next.js caches the result of that render for reuse.

Static routes:
- HTML and RSC payload are produced once at build time.
- The route cache is frozen — never re-rendered until the next build.

ISR routes:
- Cached HTML + RSC are revalidated in the background after the timer expires.
- The cache is replaced atomically — the old version serves until regeneration finishes.

Dynamic routes:
- No route cache is written.
- Each request triggers fresh rendering and fresh data fetches.

Each route’s cache entry tracks:
- Rendered HTML
- Serialized RSC payload
- Timestamps for build and last revalidation

------------------------------------------------------------
4. CDN / Edge Cache (Delivery-Level)

After build or runtime rendering, rendered artifacts are stored at the edge for instant delivery.

Static assets:
- Served directly from CDN (e.g., Vercel Edge Network).
- Cache invalidation requires a new deployment or CDN purge.

ISR routes:
- CDN serves cached content until the ISR process completes.
- Once the background revalidation finishes, CDN updates its cache automatically.

Dynamic routes:
- Typically skipped in CDN cache (Cache-Control: no-store).
- Each request reaches the origin or edge runtime for live rendering.

------------------------------------------------------------
5. How Caches Interact

1. fetch() request checks the Data Cache.
2. If found and valid → uses cached data; else → fetches new data and updates Data Cache.
3. The rendered route (using that data) is written to the Route Cache (if static or ISR).
4. The CDN caches that output for edge delivery.
5. On next request:
- CDN serves from its cache if valid.
- Route Cache regenerates output when expired.
- Data Cache may refresh individual fetch entries asynchronously.

------------------------------------------------------------
6. Request Lifecycle Example

Request: /blog
- CDN checks for cached blog.html → serves immediately if fresh.
- If expired → Next.js rerenders the route using cached data (if valid).
- If data cache also expired → fetch() refetches API data.
- Once complete, new HTML + RSC are written to both Route Cache and CDN.

Request: /dashboard
- CDN bypassed (dynamic route).
- Next.js executes server render at request time.
- fetch() calls with cache: 'no-store' skip the Data Cache.
- Response streamed live to client — nothing persisted.

------------------------------------------------------------
7. Cache Control Summary

Static:
- cache: 'force-cache'
- Route cached at build, CDN cached permanently
- Rebuild required for new data

ISR:
- next.revalidate: N seconds
- Route and data cached temporarily, auto-refreshed

Dynamic:
- cache: 'no-store'
- No persistent cache, always fresh render

------------------------------------------------------------
8. Revalidation Scenarios

Next.js performs revalidation (when cached data or rendered routes are refreshed) through several distinct mechanisms depending on cache strategy and trigger type.

ISR (time-based)
- Trigger: cache entry expires after revalidate:N seconds
- Example: export const revalidate = 300
- When: first request after expiry
- Effect: old data served while new render runs in background, cache replaced atomically

Tag-based
- Trigger: revalidateTag('tag')
- Example: await revalidateTag('posts')
- When: immediately after manual trigger (usually post-write)
- Effect: all fetches and routes using that tag re-fetch and rebuild

Path-based
- Trigger: revalidatePath('/route')
- Example: await revalidatePath('/blog')
- When: immediately after call
- Effect: invalidates route-level cache for given path

On-demand API (legacy pages)
- Trigger: res.revalidate('/path') via API route
- When: called by external CMS or webhook
- Effect: rebuilds specified ISR page

Build-time regeneration
- Trigger: new deployment or build
- When: next build executes
- Effect: clears .next/cache and regenerates all caches on first request

Dynamic triggers
- Trigger: headers(), cookies(), dynamic = 'force-dynamic', or cache:'no-store'
- When: on every request
- Effect: disables caching, always renders fresh

Manual cache purge
- Trigger: deleting .next/cache or CDN purge
- When: after CI/CD action
- Effect: drops all cached data and regenerates from scratch

------------------------------------------------------------
9. Why It Matters

- Data Cache → controls fetch granularity
- Route Cache → controls full page regeneration
- CDN Cache → controls delivery performance

Together, they define when a user sees updated data and when rendering can be skipped.
Understanding which cache your route depends on clarifies whether changes appear instantly, after revalidation, or only after redeployment.