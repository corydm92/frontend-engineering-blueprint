0. Subsection Summary

Next.js applications can run across multiple execution environments „ Node.js servers, the Edge Runtime (V8 isolates), or fully static hosting.

This subsection explains how Next.js determines where code runs, what runtime APIs are available, and how rendering behavior changes based on the deployment context.

It connects the rendering and delivery concepts from previous subsections to the runtime execution layer that actually serves requests.

---

1. Runtime Environments „ Node vs Edge
Defines the two primary runtimes Next.js supports:
- Node Runtime: Full Node.js API access, suitable for traditional SSR and API routes.
- Edge Runtime: Lightweight, low-latency V8 environment with limited APIs (no fs, process, or certain Node modules).
The runtime determines what parts of the application (server components, middleware, APIs) can execute and how fast they respond.

2. Execution Model and Request Lifecycle
Describes how Next.js handles an incoming request from start to response:
- Middleware executes first at the edge.
- Routing resolves the correct handler (page, layout, or API).
- The matched route runs inside its target runtime (Node or Edge).
- Output is rendered (HTML/RSC) and streamed or returned in full.
Establishes the base flow that all other runtime features hook into.

3. Middleware and Edge Functions
Explains how middleware intercepts requests before they reach a route.
- Runs in the Edge Runtime by default.
- Used for redirects, rewrites, authentication, and feature flags.
- Executes without blocking static file or cache responses.
Serves as the first control layer in the execution chain.

4. API Routes and Server Actions
Covers backend logic handled inside Next.js.
- API Routes: Run in Node or Edge, depending on deployment target.
- Server Actions: Allow server-side mutations invoked directly from components without client-side fetches.
Together, they unify traditional API handling with ReactÍs new server-bound capabilities.

5. Streaming and Partial Hydration
Bridges server execution with client delivery.
- The server can stream ReactÍs HTML and RSC payloads as they are generated.
- The client begins parsing and hydrating before the full response finishes.
- Enables early interactivity and lower TTFB (time to first byte).
This stage links runtime behavior with user-perceived performance.

6. Environment Boundaries and Revalidation
Defines when and how data or pages are regenerated based on runtime context.
- Node: Can handle long-running ISR revalidations and background regeneration.
- Edge: Focused on fast, stateless responses with CDN revalidation rules.
- Static: Revalidation occurs only at build time or through on-demand ISR triggers.
Finalizes how different environments manage freshness, caching, and consistency.

---

Flow: runtime selection ? request execution ? middleware interception ? data/API handling ? streaming/hydration ? revalidation and freshness management.
