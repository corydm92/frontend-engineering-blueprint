4. Render Output Pipeline — HTML & RSC Generation

Next.js prerenders all static routes at build time, producing real HTML files and serialized React Server Component (RSC) payloads.
These artifacts are served instantly at runtime, enabling immediate page loads with progressive hydration for interactive parts.

------------------------------------------------------------
1. Build-Time Rendering

When you run `next build`, Next.js walks the /app directory and executes all static routes once in a server-like environment.
Each route is evaluated just like it would be at request time — but the output is captured and stored as build artifacts.

During this process:
- Server Components are rendered into HTML fragments and serialized RSC payloads.
- Client Components are skipped during render and replaced with hydration markers.
- Async data (e.g., await fetchBlogPosts()) resolves once and becomes part of the prerendered output.

Example:
app/blog/page.tsx
export default async function Page() {
const posts = await fetchBlogPosts();
return (
<main>
{posts.map(post => <article key={post.id}>{post.title}</article>)}
</main>
);
}

At build time, this component is executed and its result is written to disk as static HTML + metadata.
The fetch runs once — not per user request.

------------------------------------------------------------
2. Output Artifacts

Next.js writes all prerendered assets under the .next directory.

Example output:
.next/

└──
server/

└──
app/
├── about.html
├── about.rsc
├── blog/
│ ├── page.html
│
└──
page.rsc

└──
_not-found.html

- .html → The prerendered markup (static shell of the route).
- .rsc → The serialized React Server Component payload containing component boundaries, props, and hydration metadata.

Together, these files represent the complete prebuilt view of each route.

------------------------------------------------------------
3. What Is Actually Sent to the Browser

When the user loads a static route, the server sends a mix of:

- Static HTML shell: real HTML from the prerendered layout and fully resolved Server Components.
- RSC payload: serialized React Flight data describing unresolved components, their props, and boundary positions.
- References to client bundles: <script> tags that load JS for each Client Component (hydration targets).

The stream is not pure HTML — it’s a structured set of instructions.
React on the client reads the RSC payload, reconstructs the component tree, and hydrates the appropriate boundaries once the JS chunks load.

Example (conceptual):
<html>
<body>
<main>
<h1>About</h1>
<div data-rsc-id="widget"></div>
</main>
<script type="text/react-flight">
["$","component","InteractiveWidget",{"props":{}}]
</script>
<script src="/_next/static/chunks/app_ui_InteractiveWidget.js"></script>
</body>
</html>

------------------------------------------------------------
4. Client Component Compilation

Client Components (marked with "use client") are never rendered at build time.
Instead, they’re compiled into static JavaScript bundles and fingerprinted for hydration.

Example client bundle output:
/next/static/chunks/app_ui_Button.js
/next/static/chunks/app_ui_InteractiveWidget.js

At runtime:
- The browser paints the prerendered HTML.
- React parses the streamed RSC payload.
- Hydration begins for each Client Component as its JS chunk loads.

------------------------------------------------------------
5. Deployment Behavior

How the prerendered files are used depends on the environment:

Static Hosting (CDN or Export)
- All .html and .rsc files are uploaded as static assets.
- Visiting /about serves /about.html directly — no Node process required.

Serverless or Edge Hosting
- .html and .rsc are cached in memory or at the edge.
- The CDN serves them instantly for static routes.
- Dynamic routes are rendered by small runtime modules instead of prebuilt files.

------------------------------------------------------------
6. Dynamic Route Difference

Dynamic routes that cannot be resolved at build time do not produce .html files.
Instead, Next.js emits a runtime render function under .next/server/app/[segment]/page.js.
When requested, the server executes this function, generates the RSC payload, and streams it to the client in the same serialized React format as static routes.

------------------------------------------------------------
7. Execution Timeline

| Phase | Action | Output |
|-------|---------|--------|
| Build Time | Execute static server components once | .html + .rsc files |
| Build Time | Compile all client components | JS chunks |
| Deploy | Upload prebuilt HTML and JS assets to CDN | Cached static files |
| Runtime (Static) | Serve prerendered HTML + RSC payload | Instant paint |
| Runtime (Dynamic) | Run server render function, stream RSC data | Progressive hydration |

------------------------------------------------------------
8. Why It’s Still “Static” with Client Components

Static routes may contain client components, but the route remains static because:
- The server never re-renders the HTML after build.
- The client receives only hydration markers and static bundle references.
- No runtime SSR occurs — only hydration in the browser.

Build-time HTML:
<main>
<h1>About</h1>
<div data-rsc-id="InteractiveWidget"></div>
</main>

At runtime:
- The static HTML paints instantly.
- The RSC payload describes where InteractiveWidget belongs.
- React loads /_next/static/chunks/app_ui_InteractiveWidget.js and hydrates it.

------------------------------------------------------------
9. Summary

- Static routes execute once at build time to produce .html and .rsc files.
- The .html file contains static markup; the .rsc file encodes the serialized React component structure.
- Client Components are compiled separately into JS bundles and hydrated in the browser.
- When served, the browser receives static HTML + RSC instructions — not full streamed HTML.
- React reconstructs the UI progressively using these streamed instructions and hydrates interactive parts as JS loads.

In essence:
Next.js doesn’t stream raw HTML — it streams structured React Flight data.
The browser paints static markup immediately, then progressively reconciles streamed RSC instructions and hydrates client components for interactivity.