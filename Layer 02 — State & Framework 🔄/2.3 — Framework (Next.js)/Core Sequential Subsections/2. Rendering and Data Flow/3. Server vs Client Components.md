3. Server vs Client Components

Next.js defines two types of React components — Server Components and Client Components — which determine where code executes, how data flows, and when the UI becomes interactive.

--------------------------------------------------------------------------------

Server Components
- Default behavior in the Next.js App Router.
- Executed on the server during render (either at build time or request time).
- Can safely access environment variables, file systems, and databases.
- Can perform async/await directly in the component body (e.g., await fetch()).
- Output is serialized as React “instructions” (RSC payload), not browser-ready HTML.
- Cannot use React hooks that depend on the browser (useState, useEffect, useLayoutEffect).
- Cannot attach event listeners or use browser APIs like window or document.

Client Components
- Declared explicitly using the "use client" directive at the top of the file.
- Bundled and sent to the browser as JavaScript for hydration.
- Enable interactivity: state, effects, event handlers, DOM manipulation.
- Cannot directly access server-only resources or run async data fetching in the render body.
- Receive data from Server Components via props.
- Should be kept as small and isolated as possible to reduce client bundle size.

--------------------------------------------------------------------------------

How They Work Together
- The render tree starts with Server Components and passes data downward.
- When the server reaches a Client Component boundary, it inserts a placeholder and records hydration metadata.
- The serialized RSC payload describes which components are client-rendered and where they should be hydrated.
- During hydration, React downloads each corresponding client JS chunk and attaches event listeners.
- Suspense boundaries coordinate between them, allowing the server to stream ready sections while the client hydrates others in parallel.

--------------------------------------------------------------------------------

Example

// Server Component (default)
import Chart from './Chart';

export default async function Dashboard() {
const data = await getRevenueData();
return <Chart data={data} />
}

// Client Component
"use client"
import { useState } from 'react';

export default function Chart({ data }) {
const [filter, setFilter] = useState('weekly');
const filtered = data[filter];
return (
<>
<button onClick={() => setFilter('monthly')}>Monthly</button>
<div>Total: {filtered.total}</div>
</>
);
}

--------------------------------------------------------------------------------

Result
- The Dashboard (server) fetches data securely and renders structure.
- The Chart (client) is compiled separately, streamed as a hydration boundary, and activated once its JS loads.
- This separation enables high performance through server-side data rendering and minimal client-side JS for interactivity.

--------------------------------------------------------------------------------

Summary
- Server Components handle data and structure.
- Client Components handle interactivity and state.
- Together they define Next.js’s hybrid rendering model — streaming data from the server while progressively hydrating client interactions.