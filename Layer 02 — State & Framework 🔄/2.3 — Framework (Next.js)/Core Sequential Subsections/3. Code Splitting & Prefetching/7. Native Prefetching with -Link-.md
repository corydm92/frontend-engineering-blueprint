7. Native Prefetching with <Link>

In production, Next.js automatically prefetches code and data for visible links.
The router watches all `<Link>` components using the Intersection Observer API and begins prefetching as soon as the link enters the viewport or is hovered.

------------------------------------------------------------
How Prefetching Works

When a `<Link>` becomes visible:
- The associated route’s JS chunk and RSC payload are fetched in the background.
- By the time the user clicks, the data and code are already in memory.
- Navigation happens instantly without a blocking network request.

Prefetching runs only in production builds — it’s disabled during development for clarity and consistency.

------------------------------------------------------------
Static vs Dynamic Routes

Static Route:
- The entire route (code + data) is prefetched.
- On click, no server call is needed — the route hydrates immediately.

Dynamic Route:
- Prefetching is skipped by default to avoid unnecessary work on the server.
- If a `loading.tsx` file exists, Next.js performs **partial prefetching**:
- The shared layout and loading skeleton are prefetched first.
- The route’s data and server-rendered payload stream in after click.

This gives users instant feedback while deferring heavy SSR until needed.

------------------------------------------------------------
Example

app/layout.tsx

import Link from 'next/link';

export default function Layout({ children }: { children: React.ReactNode }) {
return (
<html>
<body>
<nav>
{/* Prefetched when hovered or visible */}
<Link href="/dashboard">Dashboard</Link>
{/* No prefetching */}
<a href="/contact">Contact</a>
</nav>
{children}
</body>
</html>
);
}

------------------------------------------------------------
Disabling or Customizing Prefetch

You can disable automatic prefetching to reduce background activity:

<Link prefetch={false} href="/blog">
Blog
</Link>

When disabled:
- Static routes will only be fetched when clicked.
- Dynamic routes will fully SSR on navigation.

You can also prefetch only on hover for large link lists or tables:

'use client';
import Link from 'next/link';
import { useState } from 'react';

function HoverPrefetchLink({ href, children }: { href: string; children: React.ReactNode }) {
const [active, setActive] = useState(false);

return (
<Link
href={href}
prefetch={active ? null : false}
onMouseEnter={() => setActive(true)}
>
{children}
</Link>
);
}

------------------------------------------------------------
Hydration Note

Since `<Link>` is a Client Component, prefetching only begins once hydration completes.
Large JS bundles or delayed hydration can postpone prefetch, especially on slower devices.
You can monitor this behavior using `useLinkStatus()` to show visual feedback while navigation is pending.

------------------------------------------------------------
Summary

- Static routes → full prefetch (code + payload).
- Dynamic routes → partial prefetch when `loading.tsx` is present.
- Prefetching triggers when a `<Link>` becomes visible or hovered.
- Can be disabled or delayed manually for control.
- Depends on hydration; runs only in production.

Prefetching, combined with client-side transitions, makes navigation feel instantaneous even for SSR-driven applications.